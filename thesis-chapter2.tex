\chapter{РАЗРАБОТКА ПРОГРАММНОЙ БИБЛИОТЕКИ}

В этой главе подробно описывается реализация разработанной программной библиотеки по управлению приводами робота Darwin-op. В первом разделе приводится подробное описание программного интерфейса и пояснения о принятых решениях при его проектировании. Некоторые ключевые идеи также были упомянуты в предыдущей главе. После разработки интерфейса приводится математическое описание низкоуровневой части алгоритма управления и комментарии по его реализации на языке программирования C/C++.

\section{Программный интерфейс библиотеки}

Ниже, в данном разделе, представлены основные требования, на основе которых была разработана система управления сервоприводами робота, и описывается реализация абстрактных классов, которые далее будут использоваться в системе.

Основным требованием при проектировании библиотеки является возможность реализовывать алгоритмы управления на различных мобильных робототехнических системах без изменения интерфейса взаимодействия с классом. Это требование поставлено для возможности переноса  алгоритмов сложных движений, например ходьбы или удара ногой, на других роботов без фактического изменения кода, описывающего движение. Изменение кода будет происходить только на уровне механизма взаимодействия с роботом. Идею решения этой проблемы можно позаимствовать из программного пакета Nao SDK: реализовать хэш-таблицу с имеющимися частями тела в роботе и обращаться к ним по строке-ключу.

Вторым условием является возможность реализации различных алгоритмов управления в одном классе без добавления новых методов в интерфейс. Другими словами изменение позиции конечностей тела в декартовой системе координат и взаимодействие со значениями моторов напрямую должно происходит через один метод или группу методов. Например робот Darwin-Op имеет небольшое количество степеней свободы в руках, которое не позволяет производить перемещение кисти в декартовых координатах в естественной для этого движения форме. Эта проблема может так же быть решена с помощью хэш-таблицы допустимых механизмов управления. Следствием будет факт того, что некоторые виды сложных движений не будут интерпретироваться на всех роботах из-за отсутствия соответствующего механизма управления.

Общим недостатком для приведенного подхода с хэш-таблицами так же является невозможность обнаружения ошибок при обращении к этой структуре данных на стадии компиляции кода. В имени ключа может иметься опечатка или же просто отсутствовать требуемый механизм взаимодействия. Для проверки работоспособности библиотеки хорошим тоном будет написание юнит-тестов, которые проверяют работу всех механизмов управления. Так же в интерфейсе имеется метод для проверки существования метода управления. Для каждого метода взаимодействия с роботом представлен так же механизм получения элементов, доступных по ключу.

Каждый гуманоидный робот, как правило, не имеет идентичной другому роботу архитектуры тела и так же имеет свой уникальный программный пакет по взаимодействию с аппаратной частью. Данный факт показывает, что для управления роботом должен существовать механизм получения информации, например, о структуре отдельных частей робота. Для этого реализована группа методов, позволяющая по ключу получать информацию о структуре робота. Помимо недостатков методов, перечисленных в предыдущем пункте, добавляется отсутствие иерархии ключей и возможности их группирования. Эта проблема может быть решена введением конвенции именования ключей. Усложнение архитектуры данной системы сильно бы увеличило потребление памяти, поэтому было принято решение оставить ее именно в таком виде. В интерфейс включены метод, позволяющий получать данный параметр в виде строки. На стадии инициализации эти значения без труда можно будет преобразовать в требуемый тип и далее работать уже с ними. В языках, подобным C, можно было бы записывать значение в указатель на буфер, что немного увеличило производительность и избавило бы от нужды в преобразовании типов, но это усложнило бы добавление поддержки иных языков программирования, которые не поддерживают механизм указателей.

Абстрактный интерфейс так же позволяет создавать реализации алгоритма с поддержкой симулятора. Как было сказано в главе предыдущей главе, для того, чтобы поддерживать Darwin-op в симуляционной среде Webots, требуется перенаправить данные с MotionModule в соответствующие экземпляры класса Motors. Чтобы не создавать дополнительные классы и из-за того, что алгоритмы в обоих случаях идентичны за небольшими исключениями, реализация класса была спроектирована по аналогии с реализацией DARwInOPGaitManager, так же описанного в предыдущей главе.

В класс добавлены методы enable и disable. В случае, если для поддержки механизма требуется дополнительная инициализация оборудования или программных компонентов, эти методы должны реализовывать поведение активации и деактивации этих компонентов системы. В Darwin Framework экземпляр MotionModule должен быть добавлен в MotionManager и активирован через соответствующие методы. Требование активации модуля в симуляторе можно реализовать через приватный флаг enabled. Если флаг не установлен, то выводится ошибка или не происходит взаимодействие с остальными методами класса.

Для передачи значений на моторы создан метод step. На вход параметру передается время, за которое должен быть выполнен метод, по аналогии с DARwInOPGaitManager. Пересылка значений в аппаратную часть вынесена в отдельный метод для возможности реализации пошаговой симуляции и ленивых вычислений. Такая архитектура класса позволяет преобразовывать позиции конечностей из декартовой системы координат только в тот момент, когда это действительно необходимо и не производить избыточных вызовов сложных алгоритмов. Данная идея была так же позаимствована из классов, предоставленных симулятором Webots.

Ниже приведен листинг основного класса управления, на языке C/C++:

\lstset{language=C++}
\begin{lstlisting}
class RobotController {
public:
    virtual void step(int ms) = 0;

    virtual void enable() = 0;
    virtual void disable() = 0;

    virtual const std::vector<std::string>&
        getAvaliableControlMethodNames() = 0;
    virtual const std::vector<std::string>&
        getAvaliableParamNames(const std::string& method) = 0;
    virtual std::vector<std::string>& getAvaliableInfoNames() = 0;
    
    virtual bool isControlMethodAvaliable(
        const std::string& method) = 0;
    virtual bool isParamAvaliable(
        const std::string& method,
        const std::string& param) = 0;
    virtual bool isInfoAvaliable(
        const std::string& key) = 0;
    
    virtual const std::string& getInfo(
        const std::string& key) = 0;
        
    virtual void setParameter(
        const std::string& method,
        const std::string& param,
        const Data& data) = 0;
    virtual const Data& getParameter(
        const std::string& method,
        const std::string& param) = 0;
    
    virtual ~RobotController() { }
}
\end{lstlisting}

В данном листинге так же стоит обратить внимание на класс Data, который передается в качестве параметра в методе setParameter и возвращаемый в методе getParameter. Этот виртуальный класс инкапсулирует в себе данные, описывающие конкретный параметр: для работы напрямую с моторами это будет класс, содержащий конкретное значение угла, а для декартовой системы координат - значения смещения и разворота конечности относительно начала координат. В случае некорректного типа класс должен возбудить исключение.

Стоит заметить, что в классе отсутствует механизм для получения параметров, если они заранее не были установлены или было произведено движение с помощью другого класса, который работает с механикой робота. Обновление этих данных следует вынести в отдельный класс. RobotController обеспечивает лишь механизм передачи данных.

Реализация класса RobotController должна позволять управлять механикой робота на уровне отдельных параметров и величин. Механику сложных движений следует описывать в соответствующем для этого классе, так как для разных движений могут использоваться разные интерфейсы низкоуровнего управления и в этом методе описания движения, в большинстве случаев, добавляется временная составляющая как основной параметр. Для описания сложных движений в библиотеке созданы два класса: Motion и MotionController.

Абстрактный класс Motion предоставляет интерфейс, описывающий алгоритм сложного движения. В методе run описывается алгоритм движения. Дочерний класс должен реализовываться с учетом поддержки многопоточности. Подразумевается, что метод run работает в отдельном потоке. Один вызов run может описывать как несколько итераций движения, так и одно. Обращение к низкоуровневому интерфейсу робота должно происходить так же в этом методе. Метод stop должен передавать сигнал остановки движения, метод reset - сбросить состояние движения на начальное. Функция update принимает указатель на другой экземпляр Motion. Вызов метода получает состояние из движения, переданного в аргументе. Этот метод позволяет, например, изменить скорость движения робота или скорректировать направление удара во время выполнения движения. Так же в этом методе можно описать алгоритм перехода из одного движения в другое без фактической остановки. Класс Motion не привязан к конкретному низкоуровневому механизму управления. Это позволяет использовать несколько модулей управления для управления движениями. Так же в класс позволяет получать информацию о том, закончено ли движение. В случае, если движение бесконечное, метод всегда возвращает отрицательное значение. Ниже приведен листинг класса Motion:

\lstset{language=C++}
\begin{lstlisting}
class Motion {
public:
    virtual void run() = 0;
    virtual void stop() = 0;
    virtual void reset() = 0;
    virtual void update(const Motion * motion) = 0;
    virtual bool finished() const = 0;
    virtual ~Motion() { };
};
\end{lstlisting}

MotionController реализует механизм управления движениями робота. Запуск контроллера создает отдельный поток, в котором вызывается метод run активного движения, пока у того не установлен флаг окончания этого движения. Этот  так же класс позволяет установить запрос на обновление или сброс состояния движения после его завершения. Эта особенность может использоваться если система создала новое движение, которое следует обработать по завершении предыдущего, но при этом она не должна в основном потоке ждать завершения текущего движения. Движение может так же быть установлено и без ожидания завершения. Следует заметить, что не следует устанавливать флаг ожидания при вызове этих функций, если движение, которое воспроизводится в данный момент, никогда не устанавливает индикатор его окончания. Ниже приведен листинг этого класса:

\lstset{language=C++}
\begin{lstlisting}
class MotionController {
    public:
    MotionController();
    ~MotionController();
        
    void run();
    void setMotion(Motion* motion, bool wait = true);
    Motion* getMotion() const;    
    void reset(bool wait = true);
    void stop();
    bool finished() const;
        
private:
    bool set_new_motion;
    bool reset_motion;
    Motion* new_motion;
    Motion* motion;

    void updateMotionVariable(Motion* motion);
};
\end{lstlisting}

Для компиляции контроллера движения требуется поддержка стандарта не ниже C++11. Метод run для создания потока использует класс Thread, введенного в этом стандарте. В компиляторе gcc поддержка многопоточности стандарта C++11 начала стабильно поддерживаться только начиная с версии 4.8. Предыдущие версии могут поддерживать многопоточность не полностью. Сборка контроллера производилась на компиляторе версии 5.1. В Webots многопоточность организованно с помощью библиотеки pthead, но использование механизма многопоточности, предоставляемого компилятором, позволяет осуществлять ему соответствующие оптимизации, заложенные в сам компилятор.

\section{Алгоритм управления}

Этот раздел описывает реализацию алгоритма управления, реализованного для Darwin-op. В предыдущем разделе был описан интерфейс для организации системы управления. Класс, реализующий алгоритм, наследуется от RobotController и предоставляет разработчику работать с моторами робота напрямую, либо через управление конечностями робота в декартовой системе координат.

Управление моторами робота осуществляется через классы  Webots и Darwin Framework. Принцип поддержки симуляции был описан ранее. Значения хранятся во внутренних переменных и передаются на моторы только при вызове команды отправки данных step. Подробная реализация не представляет особого интереса и рассматриваться в данном разделе не будет.

Управление роботом в декартовой системе координат позволяет контролировать положение стоп робота и его туловища. Из-за структурных особенностей робота управление руками в декартовой системе координат было исключено. Перемещение кисти по прямой вдоль одной из осей координат приводит к неестественному и сложному движению. Для управления руками робота Darwin достатачно управления моторами напрямую.

Перемещение ног и туловища в пространстве имеют общую природу. Туловище робота состоит из единого блока и не имеет своих степеней свободы. Перемещение и вращение туловища можно достичь путем изменения позиций ног. 

Стопы и туловище имеют различные положения начала системы координат. Класс предоставляет возможность линейно сместить начала координат для ног. У каждой ноги началом координат считается точка крепления бедра к туловищу. Координаты стопы $(0.0, 0.0, 0.0)$ без смещения начала координат можно математически интерпретировать как состояние, если бы стопа совпадала с корпусом робота в месте крепления ноги. Началом координат для туловища считается паховая область робота, а если точнее, то это точка, находящаяся в середине нижней плоскости туловища. Вращение корпуса робота так же происходит вокруг данной точки. Начало координат каждой ноги смещено от центра на расстояние $y_offset$.

Каждая часть тела отписывается шестью параметрами: смещением по оси $x$, смещением по оси $y$, смещение по оси $z$, вращение вокруг оси $x$, вращение вокруг оси $y$, вращение вокруг оси $z$. Для ноги эти параметры описывают положение и ориентацию стопы в пространстве. При нулевых значениях вращения стопа остается параллельна плоскости $XY$. Туловище по умолчанию имеет вертикальную ориентацию вдоль оси $z$.

Управление моторами в декартовой системе координат оперирует со всей группой моторов на ногах. Изменение координат приведет к изменению позиции мотора. Исходя из этого факта стоит заметить, что управление отдельными моторами стоит производить после операций управления конечностями в пространстве. Расчет всех позиций моторов происходит только в момент передачи данных или в момент изменения угла поворота для отдельной ноги. Два изменения позиции стопы в декартовой системе координат, идущие подряд, не будут вызывать пересчет положения всех моторов. Этот прием позволят уменьшить вычислительную нагрузку на ограниченные вычислительные ресурсы робота. При изменении параметров туловища  так же выполняется перерасчет всех моторов на ногах.

Далее приводится описание алгоритма решения задачи обратной кинематики для группы туловище-ноги. 

Для описания преобразований используются матрицы переноса $T$ и матрицы вращения $R$ для трехмерного пространства.

Параметры отдельной стопы можно записать следующим произведением матриц преобразований:

\begin{equation}
A = R_{\psi} R_{\chi} R_{\phi} T
\end{equation}

\noindent где,
$ R_{\psi} = \begin{pmatrix}
1 && 0 && 0 && 0 \\
0 && \cos \psi &&  \sin \psi && 0 \\
0 && -\sin \psi && \cos \psi && 0 \\
0 && 0 && 0 && 1 \\
\end{pmatrix}$,
$ R_{\chi} = \begin{pmatrix}
\cos \chi &&  \sin \chi && 0 && 0 \\
-\sin \chi && \cos \chi && 0 && 0 \\
0 && 0 && 1 && 0 \\
0 && 0 && 0 && 1 \\
\end{pmatrix}$, \\
$ R_{\phi} = \begin{pmatrix}
\cos \phi &&  0 && \sin \phi && 0 \\
0 && 1 && 0 && 0 \\
-\sin \phi && 0 && \cos \phi && 0 \\
0 && 0 && 0 && 1 \\
\end{pmatrix}$,
$ T = \begin{pmatrix}
1 && 0 && 0 && a \\
0 && 1 && 0 && b \\
0 && 0 && 1 && c \\
0 && 0 && 0 && 1 \\
\end{pmatrix}$.

Решение задачи обратной кинематики состоит из вычисления позиций моторов $M$ для достижении заданной позиции и ориентации в конечной точке цепи связанных объектов, в данном случае бедра, голени и стопы.

Самым оптимальным методом решения задачи обратной кинематики является геометрический подход. Из-за ограниченной вычислительной мощности центрального процессора робота данных подход может сильно сэкономить время вычисления, избегая матричных операций, и тем самым увеличить производительность кода.

Пусть начальные позиции ног задаются следующей парой векторов:

\begin{center}
$F^{0}_{l} = \begin{pmatrix}
x_l \\
y_l \\
z_l \\
\end{pmatrix}$,
$F^{0}_{r} = \begin{pmatrix}
x_r \\
y_r \\
z_r \\
\end{pmatrix}$,
\end{center}

Требуемую ориентацию стоп зададим другой парой векторов:

\begin{center}
$T^{0}_{l} = \begin{pmatrix}
\phi_l \\
\chi_l \\
\psi_l \\
\end{pmatrix}$,
$T^{0}_{r} = \begin{pmatrix}
\phi_r \\
\chi_r \\
\psi_r \\
\end{pmatrix}$.
\end{center}

К позиции каждой ноги добавляется значение смещения начала координат каждой ноги и значение смещения тела.  Таким образом, позиция ноги, записанная выше, принимает следующий вид:


\begin{center}
$F^{1}_{l} = \begin{pmatrix}
F^{0}_{l,1} + sx_l + bx \\
F^{0}_{l,2} + sy_l + by \\
F^{0}_{l,3} + sz_l + bz \\
\end{pmatrix}$, $F^{1}_{r} = \begin{pmatrix}
F^{0}_{r,1} + sx_r + bx \\
F^{0}_{r,2} + sy_r + by \\
F^{0}_{r,3} + sz_r + bz \\
\end{pmatrix}$,
\end{center}

\noindent где $sx$, $sy$ и $sz$ - смещение начала координат для соответствующей ноги; $bx$, $by$, $bz$ - смещение туловища.

Вращение туловища вокруг оси $z$ на угол $\psi$ происходит путем вращения начала координат ноги вокруг начала координат туловища по оси $z$:

\begin{center}
$F^{2}_{l} = \begin{pmatrix}
F^{1}_{l,x} \cos \psi +( F^{1}_{l,y} - y\_offset) \sin \psi \\
(F^{1}_{l,2} - y\_offset) \cos \phi - F^{1}_{l,2} \sin \psi + y\_offset \\
F^{1}_{l,3} \\
\end{pmatrix}$, $F^{2}_{r} = \begin{pmatrix}
F^{1}_{r,x} \cos \psi +( F^{1}_{r,y} + y\_offset) \sin \psi \\
(F^{1}_{r,2} + y\_offset) \cos \psi - F^{1}_{r,2} \sin \psi - y\_offset \\
F^{1}_{r,3} \\
\end{pmatrix}$,\\
$T^{1}_{l} = \begin{pmatrix}
T^{0}_{l,1} \\
T^{0}_{l,2} \\
T^{0}_{l,3} - \psi \\
\end{pmatrix}$,
$T^{1}_{r} = \begin{pmatrix}
T^{0}_{r,1} \\
T^{0}_{r,2} \\
T^{0}_{r,3} - \psi \\
\end{pmatrix}$.
\end{center}

На данном этапе пропускается применение вращении вокруг оси $y$ на угол $\chi$. Наклон туловища будет добавлен к конечным значениям моторов на бедрах. Этот ход позволит уменьшить количество вычислений для этого преобразования.

Вращение туловища вокруг оси $x$ на угол $\phi$ происходит путем вращения начала координат ноги вокруг начала координат туловища по оси $x$:

\begin{center}
$F^{3}_{l} = \begin{pmatrix}
F^{2}_{l,1} \\
(F^{2}_{l,2} + y\_offset) \cos \phi - F^{2}_{l,3} \sin \phi - y\_offset \\
(F^{2}_{l,2} + y\_offset) \sin \phi + F^{2}_{l,3} \cos \phi \\
\end{pmatrix}$, $F^{3}_{r} = \begin{pmatrix}
F^{2}_{r,1} \\
(F^{2}_{r,2} - y\_offset) \cos \phi - F^{2}_{r,3} \sin \phi + y\_offset \\
(F^{2}_{r,2} - y\_offset) \sin \phi + F^{2}_{r,3} \cos \phi \\
\end{pmatrix}$,\\
$T^{2}_{l} = \begin{pmatrix}
T^{1}_{l,1} + \phi \cos T^{1}_{l,3} \\
T^{1}_{l,2} - \phi \sin T^{1}_{l,3} \\
T^{1}_{l,3} \\
\end{pmatrix}$,
$T^{2}_{r} = \begin{pmatrix}
T^{1}_{r,1} + \phi \cos T^{1}_{r,3}  \\
T^{1}_{r,2} - \phi \sin T^{1}_{r,3}  \\
T^{1}_{r,3} \\
\end{pmatrix}$.
\end{center}

Стоит заметить, что операция вращения туловища вокруг оси $x$ изменяет ориентацию стопы в зависимости от ориентации этой стопы по оси $z$.

Далее происходит расчет позиций отдельных моторов. Длины составных частей робота представлены в виде констант $thigh\_length$ (длина бедра), $calf\_length$ (длина голени), $ankle\_length$ (высота стопы).

При расчете углов сначала происходит поворот плоскости ноги $XZ$ вокруг оси $z$ на угол $T^{2}_{3}$. Все остальные расчеты происходят в рамках этой плоскости через поиск углов треугольников. 

Формулы для расчета отдельных моторов для левой ноги приведены ниже:

\begin{center}
$M_{l,hip\_roll} = T^{2}_{l,3}$,

$M_{l,hip\_yaw} = \arctan \dfrac{F^{3}_{l,2} \cos T^{2}_{l,3} - F^{3}_{l,1} \sin T^{2}_{l,3}}{F^{3}_{l,3} - ankle\_length}$,

$M_{l,hip\_pitch} = \arctan \dfrac{  F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}  }{  F^{3}_{l,3} - ankle\_length  } + \arccos \dfrac{  (F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2}  + thigh\_length^{2} - calf\_length ^ 2 }{ 2 thigh\_length \sqrt{(F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2}}}$,

$M_{l,knee} = -\pi + \arccos \dfrac{(thigh\_length ^ {2} + calf\_length ^ {2} - (F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2})} {2 thigh\_length} $

$M_{l,ankle_pitch} = -\pi + \arccos \dfrac{(thigh\_length ^ {2} + calf\_length ^ {2} - (F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2})} {2 thigh\_length} + \arctan \dfrac{  F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}  }{  F^{3}_{l,3} - ankle\_length  } + \arccos \dfrac{  (F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2}  + thigh\_length^{2} - calf\_length ^ 2 }{ 2 thigh\_length \sqrt{(F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2}}} - T^{2}_{l,2}$,

$M_{l,ankle\_yaw} = \arctan \dfrac{F^{3}_{l,2} \cos T^{2}_{l,3} - F^{3}_{l,1} \sin T^{2}_{l,3}}{F^{3}_{l,3} - ankle\_length} + T^{2}_{l,1}$
\end{center}

Далее приведены формулы для расчета моторов на правой ноге ноге.

\begin{center}
$M_{r,hip\_roll} = T^{2}_{r,3}$,

$M_{r,hip\_yaw} = \arctan \dfrac{F^{3}_{r,2} \cos T^{2}_{r,3} - F^{3}_{r,1} \sin T^{2}_{r,3}}{F^{3}_{r,3} - ankle\_length}$,

$M_{r,hip\_pitch} = -\arctan \dfrac{  F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}  }{  F^{3}_{r,3} - ankle\_length  } - \arccos \dfrac{  (F^{3}_{r,3} - ankle\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2}  + thigh\_length^{2} - carf\_rength ^ 2 }{ 2 thigh\_length \sqrt{(F^{3}_{r,3} - ankle\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2}}}$,

$M_{r,knee} = \pi - \arccos \dfrac{(thigh\_rength ^ {2} + calf\_length ^ {2} - (F^{3}_{r,3} - ankle\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2})} {2 thigh\_length} $

$M_{r,ankle_pitch} = \pi - \arccos \dfrac{(thigh\_length ^ {2} + calf\_length ^ {2} - (F^{3}_{r,3} - ankre\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2})} {2 thigh\_length} -\arctan \dfrac{  F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}  }{  F^{3}_{r,3} - ankle\_length  } - \arccos \dfrac{  (F^{3}_{r,3} - ankle\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2}  + thigh\_length^{2} - carf\_length ^ 2 }{ 2 thigh\_length \sqrt{(F^{3}_{r,3} - ankle\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2}}} + T^{2}_{r,2}$,

$M_{r,ankle\_yaw} = \arctan \dfrac{F^{3}_{r,2} \cos T^{2}_{r,3} - F^{3}_{r,1} \sin T^{2}_{r,3}}{F^{3}_{r,3} - ankle\_length} + T^{2}_{r,1}$.
\end{center}

Как было сказано ранее, наклон туловища вокруг оси $y$ будет добавляться к значениям моторов после основной группы вычислений. Таким образом вычисление моторов $M_{hip\_pitch}$ и $M_{hip\_roll}$, упомянутое выше, будет выглядеть следующим образом:

\begin{center}
$M_{r,hip\_roll} = T^{2}_{r,3} + \chi \cos T^{2}_{r,3}$

$M_{r,hip\_pitch} = -\arctan \dfrac{  F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}  }{  F^{3}_{r,3} - ankle\_length  } - \arccos \dfrac{  (F^{3}_{r,3} - ankle\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2}  + thigh\_length^{2} - carf\_rength ^ 2 }{ 2 thigh\_length \sqrt{(F^{3}_{r,3} - ankle\_length)^{2} + (F^{3}_{r,1} \cos T^{2}_{r,3} + F^{3}_{r,2} \sin T^{2}_{r,3}) ^ {2}}} + \chi \sin T^{2}_{r,3}$,

$M_{l,hip\_roll} = T^{2}_{l,3} - \chi \sin T^{2}_{r,3}$,

$M_{l,hip\_pitch} = \arctan \dfrac{  F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}  }{  F^{3}_{l,3} - ankle\_length  } + \arccos \dfrac{  (F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2}  + thigh\_length^{2} - calf\_length ^ 2 }{ 2 thigh\_length \sqrt{(F^{3}_{l,3} - ankle\_length)^{2} + (F^{3}_{l,1} \cos T^{2}_{l,3} + F^{3}_{l,2} \sin T^{2}_{l,3}) ^ {2}}} - \chi \sin T^{2}_{r,3}$.
\end{center}

Полученные значения $M$ передаются на соответствующие моторы робота.