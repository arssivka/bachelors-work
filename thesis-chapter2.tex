\chapter{РАЗРАБОТКА ПРОГРАММНОЙ БИБЛИОТЕКИ}

В этой главе подробно описывается реализация разработанной программной библиотеки по управлению приводами робота Darwin-op. В первом разделе приводится подробное описание программного интерфейса и пояснения о принятых решениях при его проектировании. Некоторые ключевые идеи также были упомянуты в предыдущей главе. После разработки интерфейса приводится математическое описание низкоуровневой части алгоритма управления и комметарии по его реализации на языке программирования C/C++.

\section{Программный интерфейс библиотеки}

Ниже, в данном разделе, представлены основные требования, на основе которых была разработанна система управления сервоприводами робота, и описывается реализация абстрактных классов, которые далее будут использоваться в системе.

Основным требованием при проектировании библиотеки является возможность реализовывать алгоритмы управления на различных мобильных робототехнических системах без изменения интерфейса взаимодействия с классом. Это требование поставлено для возможности переноса  алгоритмов сложных движений, например ходьбы или удара ногой, на других роботов без фактического изменения кода, описывающего движение. Изменение кода будет происходить только на уровне механизма взаимодействия с роботом. Идею решения этой проблемы можно позаимствовать из программного пакета Nao SDK: реализовать хэш-таблицу с имеющимися частями тела в роботе и обращаться к ним по строке-ключу.

Вторым условием является возможность реализации различных алгоритмов управления в одном классе без добавления новых методов в интерфейс. Другими словами изменение позиции конечностей тела в декартовой системе координат и взаимодействие со значениями моторов напрямую должно происходит через один метод или группу методов. Например робот Darwin-Op имеет небольшое количество степеней свободы в руках, которое не позволяет производить перемещение кисти в декартовых координатах в естесственной для этого движения форме. Эта проблема может так же быть решена с помощью хэш-таблицы допустимых механизмов управления. Следствием будет факт того, что некоторые виды сложных движений не будут интерпретироваться на всех роботах из-за отсутствия соответствующего механизма управления.

Общим недостатком для приведенного подхода с хэш-таблицами так же является невозможность обнаружения ошибок при обращении к этой структуре данных на стадии компиляции кода. В имени ключа может иметься опечатка или же просто отсутствовать требуемый механизм взаимодействия. Для проверки работоспособности библиотеки хорошим тоном будет написание юнит-тестов, которые проверяют работу всех механизмов управления. Так же в интерфейсе имеется метод для проверки существования метода управления. Для каждого метода взаимодействия с роботом представлен так же механизм получения элементов, доступных по ключу.

Каждый гуманоидный робот, как правило, не имеет идентичной другому роботу архитектуры тела и так же имеет свой уникальный программный пакет по взаимодействию с аппаратной частью. Данный факт показывает, что для управления роботом должен существовать механизм получения информации, например, о структуре отдельных частей робота. Для этого реализована группа методов, позволяющая по ключу получать информацию о структуре робота. Помимо недостатков методов, перечисленных в предыдущем пункте, добавляется отсутствие иерархии ключей и возможности их группирования. Эта проблема может быть решена введением конвенции именования ключей. Усложнение архитектуры данной системы сильно бы увеличило потребление памяти, поэтому было принято решение оставить ее именно в таком виде. В интерфейс включены метод, позволяющий получать данный параметр в виде строки. На стадии инициализации эти значения без труда можно будет преобразовать в требуемый тип и далее работать уже с ними. В языках, подобным C, можно было бы записывать значение в указатель на буфер, что немного увеличило производительность и избавило бы от нужды в преобразовании типов, но это усложнило бы добавление поддержки иных языков программирования, которые не поддерживают механизм указателей.

Абстрактный интерфейс так же позволяет создавать реализации алгоритма с поддержкой симулятора. Как было сказано в главе педыдущей главе, для того, чтобы поддерживать Darwin-op в симуляционной среде Webots, требуется перенаправить данные с MotionModule в соответствующие экземпляры класса Motors. Чтобы не создавать дополнительные классы и из-за того, что алгоритмы в обоих случаях идентичны за небольшими исключениями, реализация класса была спроектирована по аналогии с реализацией DARwInOPGaitManager, так же описанного в предыдущей главе.

В класс добавлены методы enable и disable. В случае, если для поддержки механизма требуется дополнительная инициализация оборудования или программных компонентов, эти методы должны реализовывать поведение активации и деактивации этих компонентов системы. В Darwin Framework экземпляр MotionModule должен быть добавлен в MotionManager и активирован через соответствующие методы. Требование активации модуля в симуляторе можно реализовать через приватный флаг enabled. Если флаг не установлен, то выводится ошибка или не происходит взаимодействие с остальными методами класса.

Для передачи значений на моторы создан метод step. На вход параметру передается время, за которое должен быть выполнен метод, по аналогии с DARwInOPGaitManager. Пересылка значений в аппаратную часть выделена в одельный метод для возможности реализации пошаговой симуляции и ленивых вычислений. Такая архитектура класса позволяет преобразовывать позиции конечностей из декартовой системы координат только в тот момент, когда это действительно необходимо и не производить избыточных вызовов сложных алгоритмов. Данная идея была так же позаимствованна из классов, предоставленных симулятором Webots.

Ниже приведен листинг основного класса управления, на языке C/C++:

\lstset{language=C++}
\begin{lstlisting}
class RobotController {
public:
    virtual void step(int ms) = 0;

    virtual void enable() = 0;
    virtual void disable() = 0;

    virtual const std::vector<std::string>&
        getAvaliableControlMethodNames() = 0;
    virtual const std::vector<std::string>&
        getAvaliableParamNames(const std::string& method) = 0;
    virtual std::vector<std::string>& getAvaliableInfoNames() = 0;
    
    virtual bool isControlMethodAvaliable(
        const std::string& method) = 0;
    virtual bool isParamAvaliable(
        const std::string& method,
        const std::string& param) = 0;
    virtual bool isInfoAvaliable(
        const std::string& key) = 0;
    
    virtual const std::string& getInfo(
        const std::string& key) = 0;
        
    virtual void setParameter(
        const std::string& method,
        const std::string& param,
        const Data& data) = 0;
    virtual const Data& getParameter(
        const std::string& method,
        const std::string& param) = 0;
    
    virtual ~RobotController() { }
}
\end{lstlisting}

В данном листинге так же стоит обратить внимание на класс Data, который передается в качестве параметра в методе setParameter и возвращаемый в методе getParameter. Этот виртуальный класс инкапсулирует в себе данные, описывающие конкретный параметр: для работы напрямую с моторами это будет класс, содержащий конкретное значение угла, а для декартовой системы координат - значения смещения и разворота конечности относительно начала координат. В случае некорректного типа класс должен возбудить исключение.

Стоит заметить, что в классе отсутствует механизм для получения параметров, если они заранее не были установлены или было произведенно движение с помощью другого класса, который работает с механикой робота. Обновление этих данных следует вынести в отдельный класс. RobotController обеспечивает лишь механизм передачи данных.

Реализация класса RobotController должна позволять управлять механикой робота на уровне отдельных параметров и величин. Механику сложных движений следует описывать в соответствующем для этого классе, так как для разных движений могут использоваться разные интерфейсы низкоуровнего управления и в этом методе описания движения, в большинстве случаев, добавляется временная составляющая как основной параметр. Для описания сложных движений в библиотеке созданы два класса: Motion и MotionController.

Абстрактный класс Motion предоставляет интерфейс, описывающий алгоритм сложного движения. В методе run описывается алгоритм движения. Дочерний класс должен реализовываться с учетом поддержки многопоточности. Подразумевается, что метод run работает в отдельном потоке. Один вызов run может описывать как несколько итераций движения, так и одно. Обращение к низкоуровневому интерфейсу робота должно происходить так же в этом методе. Метод stop должен передавать сигнал остановки движения, метод reset - сбросить состояние движения на начальное. Функция update принимает указатель на другой экземпляр Motion. Вызов метода получает состояние из движения, переданного в аргументе. Этот метод позволяет, например, изменить скорость движения робота или скорректировать направление удара во время выполнения движения. Так же в этом методе можно описать алгоритм перехода из одного движения в другое без фактической остановки. Класс Motion не привязан к конкретному низкоуровневому механизму управления. Это позволяет использовать несколько модулей управления для управления движениями. Так же в класс позволяет получать информацию о том, закончено ли движение. В случае, если движение бесконечное, метод всегда возвращает отрицательное значение. Ниже приведен листинг класса Motion:

\lstset{language=C++}
\begin{lstlisting}
class Motion {
public:
    virtual void run() = 0;
    virtual void stop() = 0;
    virtual void reset() = 0;
    virtual void update(const Motion * motion) = 0;
    virtual bool finished() const = 0;
    virtual ~Motion() { };
};
\end{lstlisting}

MotionController реализует механизм управления движениями робота. Запуск контроллера создает отдельный поток, в котором вызывается метод run активного движения, пока у того не установлен флаг окончания этого движения. Этот  так же класс позволяет установить запрос на обновление или сброс состояния движения после его завершения. Эта особенность может использоваться если система создала новое движение, которое следует обработать по завершении предыдущего, но при этом она не должна в основном потоке ждать завершения текущего движения. Движение может так же быть установленно и без ожидания завершения. Следует заметить, что не следует устанавливать флаг ожидания при вызове этих функций, если движение, которое воспроизводится в данный момент, никогда не устанавливает индикатор его окончания. Ниже приведен листинг этого класса:

\lstset{language=C++}
\begin{lstlisting}
class MotionController {
    public:
    MotionController();
    ~MotionController();
        
    void run();
    void setMotion(Motion* motion, bool wait = true);
    Motion* getMotion() const;    
    void reset(bool wait = true);
    void stop();
    bool finished() const;
        
private:
    bool set_new_motion;
    bool reset_motion;
    Motion* new_motion;
    Motion* motion;

    void updateMotionVariable(Motion* motion);
};
\end{lstlisting}

Для компиляции контроллера движения требуется поддержка стандарта не ниже C++11. Метод run для создания потока использует класс Thread, введенного в этом стандарте. В компиляторе gcc поддержка многопоточности стандарта C++11 начала стабильно поддерживаться только начиная с версии 4.8. Предыдущие версии могут поддерживать многопоточность не полностью. Сборка контроллера производилась на компиляторе версии 5.1.